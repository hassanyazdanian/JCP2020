#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
    This program is part of codes written for doi: 10.1016/j.jcp.2020.109408
    If you find the program useful in your research, please cite our work.

    Copyright (C) 2022 Hassan Yazdanin, Kim Knudsen
    
    
    Fast evaluation of Biot-Savart Integral using FFTCONVOLVE method!
    
    This is the second approach to evaluate the technique developed to
    fast computation of the Biot-Savart integral. 
    
    ---------------------------------------------------------------------------
    The input current density data was generated by SimNIBS 2.1.2.  
    The realistic simulation was run on a head model of a healthy volunteer
    from the SimNIBS example dataset (www.simnibs .org). This model is a
    tetrahedral head mesh with ≈7 ×105nodes and ≈5 ×106tetrahedral elements 
    segmented into six tissue types: white matter, gray matter, cerebrospinal
    fluid, skull, scalp and eyes, with conductivities of 0.126 S/m, 0.275 S/m,
    1.645 S/m, 0.01 S/m, 0.465 S/m and 0.5 S/m, respectively.
    
    We used SimNIBS to model two single layer rectangular electrodes of 
    50mm×50mm×4mmand used them to deliver a 1 mA current. The anode was 
    placed above the C6 position and the cathode above the C5 position 
    according to the EEG 10-20 system. For each electrode, the complete
    upper surface was set to a common electric potential, corresponding 
    to a highly conductive top layer to distribute the currents.
    
    To compute B field by FFT-based methods, it is required to convert J
    defined on the elements of the tetrahedral mesh to the points of the 
    defined regular grid. This was done using theinterpolate_to_gridfunction
    in SimNIBS, which grids the data using the superconvergent patch recovery
    (SPR)-based interpolation.
    ---------------------------------------------------------------------------
    
    Important notice: if our computation domain resides on -s to s,
    the current density field should be zero outside of (at least) -s/2 to s/2.

    If you have any question, please contact: hassanyazdanian@gmial.com.


    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

#-------------- Import_libraries
import numpy as np
from scipy import sparse
import matplotlib.pyplot as plt
from timeit import default_timer as timer

'''
    grad: compute the numerical gradient 
    
    VEC_DERIV: compute the numerical divergence and curl
    
    These functions calculate the gradient, divergence, and curl of input 
    vector field F based on forward, backward, or central difference 
    approxmation of derivative. 
'''
def grad(F,h):		# Be careful about boundaries
	ND=F.shape[0]*F.shape[1]*F.shape[2]
	e0 = -np.ones(ND-1) 
	e1 = np.ones(ND-1)
	D =sparse.diags([e0,e1], [-1,1])/(2*h)

	F1d=np.transpose(F, (0, 2, 1)).ravel()
	Fdx1d=D*F1d
	Fdx=np.reshape(Fdx1d,F.shape)
	Fdx=np.transpose(Fdx, (0, 2, 1))
	
	F1d=0
	F1d=F.T.ravel()
	Fdy1d=D*F1d
	Fdy=np.reshape(Fdy1d,F.shape)
	Fdy=Fdy.T

	F1d=0
	F1d=F.ravel()
	Fdz1d=D*F1d
	Fdz=np.reshape(Fdz1d,F.shape)
		
	return Fdx,Fdy,Fdz

def VEC_DERIV(Fx,Fy,Fz,h):
	
	Fxdx,Fxdy,Fxdz=grad(Fx,h)
	Fydx,Fydy,Fydz=grad(Fy,h)
	Fzdx,Fzdy,Fzdz=grad(Fz,h)
     
	diveF=Fxdx+Fydy+Fzdz
	
	curlFx=Fzdy-Fydz
	curlFy=Fxdz-Fzdx
	curlFz=Fydx-Fxdy
	return diveF,curlFx,curlFy,curlFz



# ------------------------Define inputs
def inputs(r,s,M): 	        
    h=s*2./M   
    x=np.linspace((-M/2+1./2)*h,(M/2-1./2)*h,M)
    X,Y,Z=np.meshgrid(x,x,x,indexing='xy',sparse=True)
    J=np.load('grided_J'+str(M)+'.npy')
  	
    Jx=J[:,:,:,0]
    Jy=J[:,:,:,1]
    Jz=J[:,:,:,2]
    J=0    
    return h,Jx,Jy,Jz

#--------------------------- B-field
def FFTCONV(h,Jx,Jy,Jz):
    
    #Fourier transform of the Biot-Savart kernel
    TIME = timer()
    k=(2*np.pi)*np.fft.fftfreq(Jx.shape[0],h)
    kx,ky,kz=np.meshgrid(k,k,k,indexing='xy',sparse=True)
    kx[0, 0, 0] = 1e-9
    K=1/(kx**2+ky**2+kz**2)
    kx[0, 0, 0]=0

    K=K[:,:,0:len(k)//2+1]
    kx=kx[:,:,0:len(k)//2+1]
    ky=ky[:,:,0:len(k)//2+1]
    kz=kz[:,:,0:len(k)//2+1]
    
    Jx_fft=np.fft.rfftn(Jx)
    Jxphi_fft=1j*kx*Jx_fft*K
    
    Jy_fft=np.fft.rfftn(Jy) 
    Jyphi_fft=1j*ky*Jy_fft*K
    
    Jz_fft=np.fft.rfftn(Jz)
    Jzphi_fft=1j*kz*Jz_fft*K
    
    Jphi_fft=Jxphi_fft+Jyphi_fft+Jzphi_fft
    
    Jxso_fft=Jx_fft+1j*kx*Jphi_fft
    Jyso_fft=Jy_fft+1j*ky*Jphi_fft
    Jzso_fft=Jz_fft+1j*kz*Jphi_fft
    
    Jxso=np.fft.irfftn(Jxso_fft)
    Jyso=np.fft.irfftn(Jyso_fft)
    Jzso=np.fft.irfftn(Jzso_fft)
    
    del Jx_fft
    del Jy_fft
    del Jz_fft

    Byh=np.multiply(1j*(K*kz),Jxso_fft)
    Bzh=np.multiply(-1j*(K*ky),Jxso_fft)
    del Jxso_fft
    
    Bxh=np.multiply(-1j*(K*kz),Jyso_fft)
    Bzh+=np.multiply(1j*(K*kx),Jyso_fft)
    del Jyso_fft
    
    Bxh+=np.multiply(1j*(K*ky),Jzso_fft)
    Byh+=-np.multiply(1j*(K*kx),Jzso_fft)
    del Jzso_fft
    
    Bxh=np.fft.irfftn(Bxh)
    Byh=np.fft.irfftn(Byh)
    Bzh=np.fft.irfftn(Bzh)
    
    TIME= timer() - TIME
    return Jxso,Jyso,Jzso,Bxh,Byh,Bzh,TIME

#-------------- Initialization
s=0.512                  # define the size ofcomputional domain  (-s to s)
r=0.256                  # radii of mask
MR=[160]      # M=2^mR[i] where M is umber of grid points in each direction.
              # MR= 160 means voxel size= 3.2 mm^2

Erms2=np.zeros(len(MR))     # Error vector
TIME=np.zeros(len(MR))      # Time vector

for ei in range(0,len(MR)):
    M=MR[ei]
    h,Jx,Jy,Jz=inputs(r,s,M)
    M_2=M/2                 # half of grid points
    M_4=M/4                 # quarter of grid points
    
    # second approach (compute the solenoidal part of current density)
    Jxso,Jyso,Jzso,Bxh,Byh,Bzh,TIME = FFTCONV(h,Jx,Jy,Jz)
    diveB,Jxsoh,Jysoh,Jzsoh = VEC_DERIV(Bxh,Byh,Bzh,h)  

    # making mask
    maskx=np.zeros(Jx.shape)
    maskx[np.nonzero(Jx)]=1	

    masky=np.zeros(Jy.shape)
    masky[np.nonzero(Jy)]=1	

    maskz=np.zeros(Jz.shape)
    maskz[np.nonzero(Jz)]=1	

    Jxsoh=Jxsoh*maskx
    Jysoh=Jysoh*masky
    Jzsoh=Jzsoh*maskz
    
    Jxso=Jxso*maskx
    Jyso=Jyso*masky
    Jzso=Jzso*maskz
    

    Erms2[ei]=100*np.sqrt(np.sum((Jxso-Jxsoh)**2)+np.sum((Jyso-Jysoh)**2)+np.sum((Jzso-Jzsoh)**2))/np.sqrt(np.sum(Jxso**2)+np.sum(Jyso**2)+np.sum(Jzso**2))

print('2nd approach error%:',Erms2 ) 

#plot a slice of current densities
plt.figure()
plt.imshow(Jy[int(M_2), int(M_2-M_4):int(M_2+M_4), int(M_2-M_4):int(M_2+M_4)])
plt.colorbar()

plt.figure()
plt.imshow(Jyso[int(M_2), int(M_2-M_4):int(M_2+M_4), int(M_2-M_4):int(M_2+M_4)])
plt.colorbar()

plt.figure()
plt.imshow(Jysoh[int(M_2), int(M_2-M_4):int(M_2+M_4), int(M_2-M_4):int(M_2+M_4)])
plt.colorbar()



