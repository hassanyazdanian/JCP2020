#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
    This program is part of codes written for doi: 10.1016/j.jcp.2020.109408
    If you find the program useful in your research, please cite our work.

    Copyright (C) 2022 Hassan Yazdanin, Kim Knudsen
    
    
    Fast evaluation of Biot-Savart Integral using FFTCONVOLVE method!
    
    This is the second approach to evaluate the technique developed to
    fast computation of the Biot-Savart integral. 
    
    ---------------------------------------------------------------------------
    The input current density data was generated by SimNIBS 2.1.2.  
    The realistic simulation was run on a head model of a healthy volunteer
    from the SimNIBS example dataset (www.simnibs .org). This model is a
    tetrahedral head mesh with ≈7 ×105nodes and ≈5 ×106tetrahedral elements 
    segmented into six tissue types: white matter, gray matter, cerebrospinal
    fluid, skull, scalp and eyes, with conductivities of 0.126 S/m, 0.275 S/m,
    1.645 S/m, 0.01 S/m, 0.465 S/m and 0.5 S/m, respectively.
    
    We used SimNIBS to model two single layer rectangular electrodes of 
    50mm×50mm×4mmand used them to deliver a 1 mA current. The anode was 
    placed above the C6 position and the cathode above the C5 position 
    according to the EEG 10-20 system. For each electrode, the complete
    upper surface was set to a common electric potential, corresponding 
    to a highly conductive top layer to distribute the currents.
    
    To compute B field by FFT-based methods, it is required to convert J
    defined on the elements of the tetrahedral mesh to the points of the 
    defined regular grid. This was done using theinterpolate_to_gridfunction
    in SimNIBS, which grids the data using the superconvergent patch recovery
    (SPR)-based interpolation.
    ---------------------------------------------------------------------------
    
    Important notice: if our computation domain resides on -s to s,
    the current density field should be zero outside of (at least) -s/2 to s/2.

    If you have any question, please contact: hassanyazdanian@gmial.com.


    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

#-------------- Import_libraries
import numpy as np
from scipy import sparse
from scipy.fftpack import fft, fft2, fftn
import matplotlib.pyplot as plt
import time


# ------------------------ Define inputs
def inputs(r,s,M): 	        
    h=s*2./M   
    x=np.linspace((-M/2+1./2)*h,(M/2-1./2)*h,M)
    X,Y,Z=np.meshgrid(x,x,x,indexing='xy',sparse=True)
    J=np.load('grided_J'+str(M)+'.npy')
  	
    Jx=J[:,:,:,0]
    Jy=J[:,:,:,1]
    Jz=J[:,:,:,2]
    J=0    
    return h,Jx,Jy,Jz

#------------------ Circular convolution by using FFT method 
def FFTCONV(h,Jx,Jy,Jz):
    ''' Calculates the magnetic field caused by a current density distribution Jx, Jy, and Jz '''
    
    
    #Fourier transform of the Biot-Savart kernel
    k = 2*np.pi*np.fft.fftfreq(Jx.shape[0],h)
    kx, ky, kz = np.meshgrid(k,k,k,indexing='ij',sparse=True)
    kx[0,0,0] = 1e-9
    K=1j/(kx**2+ky**2+kz**2)
    K[0,0,0]=0
    
    Jx_fft = np.fft.rfftn(Jx)
    Byh = np.multiply((K*kz)[:,:,0:len(K)//2+1],Jx_fft)
    Bzh = np.multiply(-(K*ky)[:,:,0:len(K)//2+1],Jx_fft)
    del Jx_fft

    Jy_fft = np.fft.rfftn(Jy)
    Bxh = np.multiply(-(K*kz)[:,:,0:len(K)//2+1],Jy_fft)
    Bzh += np.multiply((K*kx)[:,:,0:len(K)//2+1],Jy_fft)
    del Jy_fft

    Jz_fft = np.fft.rfftn(Jz)
    Bxh += np.multiply((K*ky)[:,:,0:len(K)//2+1],Jz_fft)
    Byh += np.multiply(-(K*kx)[:,:,0:len(K)//2+1],Jz_fft)
    del Jz_fft

    Bxh = np.fft.irfftn(Bxh)
    Byh = np.fft.irfftn(Byh)
    Bzh = np.fft.irfftn(Bzh)
      
    return Bxh, Byh, Bzh

#-------------- Initialization
s=0.512                  # define the size ofcomputional domain  (-s to s)
r=0.256                  # radii of mask
MR=[160]      # M=2^mR[i] where M is umber of grid points in each direction.
              # MR= 160 means voxel size= 3.2 mm^2

TIME = np.zeros(len(MR))    # Time vector
              
for idx in range(0,len(MR)):
    M=MR[idx]
    h,Jx,Jy,Jz=inputs(r,s,M)
    M_2=M/2                 # half of grid points
    M_4=M/4                 # quarter of grid points
    
    time_start = time . time ()
    Bxh, Byh ,Bzh = FFTCONV(h,Jx,Jy,Jz)
    TIME [idx] = time . time ()-time_start
    

#plot a slice of magnetic field components
plt.figure()
plt.imshow(Bxh[int(M_2), int(M_2-M_4):int(M_2+M_4), int(M_2-M_4):int(M_2+M_4)])
plt.colorbar()
    
plt.figure()
plt.imshow(Byh[int(M_2), int(M_2-M_4):int(M_2+M_4), int(M_2-M_4):int(M_2+M_4)])
plt.colorbar()

plt.figure()
plt.imshow(Bzh[int(M_2), int(M_2-M_4):int(M_2+M_4), int(M_2-M_4):int(M_2+M_4)])
plt.colorbar()